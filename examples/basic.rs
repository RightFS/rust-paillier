extern crate paillier;

use std::borrow::Cow;
use paillier::*;

#[cfg(not(feature = "keygen"))]
fn main() {
    println!("*** please run with 'keygen' feature ***")
}
fn test_keypair() -> Keypair {
    let p = str::parse("148677972634832330983979593310074301486537017973460461278300587514468301043894574906886127642530475786889672304776052879927627556769456140664043088700743909632312483413393134504352834240399191134336344285483935856491230340093391784574980688823380828143810804684752914935441384845195613674104960646037368551517").unwrap();
    let q = str::parse("158741574437007245654463598139927898730476924736461654463975966787719309357536545869203069369466212089132653564188443272208127277664424448947476335413293018778018615899291704693105620242763173357203898195318179150836424196645745308205164116144020613415407736216097185962171301808761138424668335445923774195463").unwrap();
    Keypair { p, q }
}
#[cfg(feature = "keygen")]
fn main() {
    // first generate a fresh keypair, where
    // the encryption key can be made public
    // while the decryption key should remain private
    //let (ek, dk) = Paillier::keypair().keys();

    let (ek, dk) = test_keypair().keys();
    println!("ek: {:?}", ek);
    println!("dk: {:?}", dk);
    let cipher: BigInt = str::parse("65886454194865119109045067098063585819132104214898227207768873626266288576307667154771415855790121857158792928396135697576082639717271899289459877975809133982190427853871687217214186407233498331138220767517302662915228337342914353827839433910613805330180499253900041708735598011568377650374650439086075495460124898140618875682688264266924959315655785517385410380685387536692244797356049779384024511245755138835684324972200551202833466217248718553568012302343005419599354799933128090164159214674662518377664080946959330957278538841542418655753713774825506139593347007258654120216806277883787486418158236508679409736505365732307937561416826521763951071194009223718886273844952806922258545179785419489317972831324055514017180293564875052526100184510673922152028723552013028956773818704909302785539736463866860422035670087951054038648813804648321943752751275042564226446544714438081588229826218452308642439531767093816472375239145447304508630637759979364228413046684699755845622315535689472083715520405164657906213700988486496852861453944771309884530453786699020522012641805211697637701596225086843881891403889162810589091357612509869998971164569040263942108873477561609066325058332364756141628367794577896373151883654834135306070773486").unwrap();
    let res = Paillier::decrypt(&dk,RawCiphertext(Cow::Owned(cipher)));
    println!("decrypt: {:?}",res);
    // after sharing the encryption key anyone can encrypt values
    let c1 = Paillier::encrypt(&ek, 10);
    let c2 = Paillier::encrypt(&ek, 20);
    let c3 = Paillier::encrypt(&ek, 30);
    let c4 = Paillier::encrypt(&ek, 40);

    // and anyone can perform homomorphic operations on encrypted values,
    // e.g. multiplication with unencrypted values
    let d1 = Paillier::mul(&ek, c1, 4);
    let d2 = Paillier::mul(&ek, c2, 3);
    let d3 = Paillier::mul(&ek, c3, 2);
    let d4 = Paillier::mul(&ek, c4, 1);
    // ... or addition with encrypted values
    let d = Paillier::add(&ek, Paillier::add(&ek, d1, d2), Paillier::add(&ek, d3, d4));

    // after all homomorphic operations are done the result
    // should be re-randomized to hide all traces of the inputs
    let d = Paillier::rerandomize(&ek, d);
    println!("{:?}",d);
    // finally, only the one with the private decryption key
    // can retrieve the result
    let m = Paillier::decrypt(&dk, &d);
    println!("Decrypted value is {}", m);
}
